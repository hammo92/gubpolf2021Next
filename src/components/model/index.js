/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output. 
*/
import { Spacer, Flex, Box } from "@chakra-ui/react";
import React, { useEffect, useState, useMemo, useCallback } from "react";
import {
    useGLTF,
    useTexture,
    useCursor,
    useAnimations,
    useSimplification,
    Html,
} from "@react-three/drei";
import { useGraph } from "@react-three/fiber";
import { a, useSpring } from "@react-spring/three";
import { SkeletonUtils } from "three-stdlib";

const hiddenNodes = ["Ch33_Eyelashes"];
const shirtColour = ["hotpink", "aquamarine", "white", "orange"];
const jacketOptions = ["hotpink", "gray", "black", "navy"];
const hairOptions = ["black", "#F0E2B6", "#b06500", "#654321"];
const shoeOptions = ["black", "brown", "white"];
const trouserOptions = [
    "hotpink",
    "aquamarine",
    "white",
    "orange",
    "black",
    "navy",
];
const nonTextured = ["Ch33_Tie", "Ch33_Shirt", "Ch33_Hair"];

export default function Model({ pose, modelIndex, golfer, ...props }) {
    // Fetch model and a separate texture
    const { scene, animations } = useGLTF("/drunkMan.glb");
    console.log(`scene`, scene);
    const [colours, setColours] = useState({
        shirt: "#ffffff",
        trousers: "#ffffff",
        jacket: "#ffffff",
        hair: "#000000",
        shoe: "#000000",
    });
    const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
    const { nodes } = useGraph(clone);
    const textures = [
        useTexture("/Ch33_1001_Diffuse_green.png"),
        useTexture("/Ch33_1001_Diffuse2.png"),
    ];
    useEffect(() => {
        setColours({
            shirt: shirtColour[Math.floor(Math.random() * shirtColour.length)],
            trousers:
                trouserOptions[
                    Math.floor(Math.random() * trouserOptions.length)
                ],
            jacket: jacketOptions[
                Math.floor(Math.random() * trouserOptions.length)
            ],
            hair: hairOptions[Math.floor(Math.random() * hairOptions.length)],
            shoe: shoeOptions[Math.floor(Math.random() * shoeOptions.length)],
        });
    }, []);
    // Extract animation actions
    const { ref, actions, names } = useAnimations(animations);
    // Hover and animation-index states
    const [hovered, setHovered] = useState(false);
    const [index, setIndex] = useState(pose);
    // Animate the selection halo
    const { color, scale } = useSpring({
        scale: hovered ? [1.15, 1.15, 1] : [1, 1, 1],
        color: hovered ? "hotpink" : "aquamarine",
    });
    const setColor = (key) => {
        if (key === "Ch33_Tie") return "green";
        if (key === "Ch33_Shirt") return colours.shirt;
        if (key === "Ch33_Pants") return colours.trousers;
        if (key === "Ch33_Suit") return colours.jacket;
        if (key === "Ch33_Hair") return colours.hair;
        if (key === "Ch33_Hair") return colours.shoe;
        return null;
    };

    // Change cursor on hover-state
    useCursor(hovered);
    // Change animation when the index changes
    useEffect(() => {
        // Reset and fade in animation after an index has been changed
        actions[names[index]].reset().fadeIn(0.5).play();
        // In the clean-up phase, fade it out
        return () => actions[names[index]].fadeOut(0.5);
    }, [index, actions, names]);
    return (
        <group ref={ref} {...props} dispose={null}>
            <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>
                <primitive object={nodes.mixamorig7Hips} />
                {Object.keys(nodes).map((nodeKey) => {
                    const node = nodes[nodeKey];
                    if (
                        node.type === "SkinnedMesh" &&
                        !hiddenNodes.includes(nodeKey)
                    )
                        return (
                            <skinnedMesh
                                castShadow
                                receiveShadow
                                geometry={node.geometry}
                                skeleton={node.skeleton}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={[100, 100, 100]}
                            >
                                <meshStandardMaterial
                                    map={
                                        nonTextured.includes(nodeKey)
                                            ? null
                                            : textures[1]
                                    }
                                    color={setColor(nodeKey)}
                                    map-flipY={
                                        nonTextured.includes(nodeKey)
                                            ? undefined
                                            : false
                                    }
                                    skinning
                                />
                            </skinnedMesh>
                        );
                })}
            </group>
            <group
                onPointerOver={() => setHovered(true)}
                onPointerOut={() => setHovered(false)}
            >
                <a.mesh receiveShadow position={[0, 2.5, 0]} scale={scale}>
                    <a.meshStandardMaterial color={color} />
                    <Html distanceFactor={10}>
                        <Box position="relative">
                            <Box
                                background="#dedede"
                                p={10}
                                position="relative"
                                left="-50%"
                                cursor="pointer"
                                onClick={() =>
                                    setIndex((index + 1) % names.length)
                                }
                                whiteSpace="nowrap"
                                borderRadius="5px"
                            >
                                <span>{`${golfer.firstName__B} ${golfer.secondName__A}`}</span>
                            </Box>
                        </Box>
                    </Html>
                </a.mesh>
            </group>
        </group>
    );
}
